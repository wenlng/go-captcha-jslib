import{DirtyLevels}from"./constants";export function effect(e,t){const i=new ReactiveEffect(e,(()=>{i.run()}));i.run(),t&&Object.assign(i,t);const r=i.run.bind(i);return r.effect=i,r}export let activeEffect;export let shouldTrack;export function isTracking(){return shouldTrack&&void 0!==activeEffect}function preCleanEffect(e){e._depsLength=0,e._trackId++}function postCleanEffect(e){if(e.deps.length>e._depsLength){for(let t=e._depsLength;t<e.deps.length;t++)cleanDepEffect(e.deps[t],e);e.deps.length=e._depsLength}}export class ReactiveEffect{constructor(e,t){this.fn=e,this.scheduler=t,this._trackId=0,this._depsLength=0,this._running=0,this._dirtyLevel=DirtyLevels.Dirty,this.deps=[],this.active=!0}get dirty(){return this._dirtyLevel===DirtyLevels.Dirty}set dirty(e){this._dirtyLevel=e?DirtyLevels.Dirty:DirtyLevels.NoDirty}run(){if(this._dirtyLevel=DirtyLevels.NoDirty,!this.active)return this.fn();let e=activeEffect;try{return activeEffect=this,shouldTrack=!0,preCleanEffect(this),this._running++,this.fn()}finally{this._running--,postCleanEffect(this),shouldTrack=!1,activeEffect=e}}stop(){this.active&&(this.active=!1,preCleanEffect(this),postCleanEffect(this))}}function cleanDepEffect(e,t){e.delete(t),0==e.size&&e.cleanup()}export function trackEffect(e,t){if(t.get(e)!==e._trackId){t.set(e,e._trackId);let i=e.deps[e._depsLength];i!==t?(i&&cleanDepEffect(i,e),e.deps[e._depsLength++]=t):e._depsLength++}}export function triggerEffects2(e){for(const t of e)t._dirtyLevel<DirtyLevels.Dirty&&(t._dirtyLevel=DirtyLevels.Dirty),t._running||t.scheduler&&t.scheduler()}export function triggerEffects(e){for(const t of e.keys())t._dirtyLevel<DirtyLevels.Dirty&&(t._dirtyLevel=DirtyLevels.Dirty),t._running||t.scheduler&&t.scheduler()}