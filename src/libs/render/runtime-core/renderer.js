import{ShapeFlags}from"../shared";import{Fragment,Text,createVnode,isSameVnode}from"./createVnode";import getSequence from"./seq";import{ReactiveEffect,isRef}from"../reactivity";import{queueJob}from"./scheduler";import{createComponentInstance,setupComponent}from"./component";import{invokeArray}from"./apiLifecycle";import{isKeepAlive}from"./components/KeepAlive";import{PatchFlags}from"../shared";import{PropsFlags}from"../shared/propsFlags";import{DefaultSvgURI,SvgTagArray}from"../shared/tagNames";export function createRenderer(e){const{insert:n,remove:t,createElement:l,createElementNS:r,createText:o,setText:a,setElementText:s,parentNode:p,nextSibling:i,patchProp:c}=e,u=e=>{if(Array.isArray(e))for(let n=0;n<e.length;n++)"string"!=typeof e[n]&&"number"!=typeof e[n]||(e[n]=createVnode(Text,null,String(e[n])));return e},m=(e,n,t,l)=>{u(e);for(let r=0;r<e.length;r++)R(null,e[r],n,t,l)},h=(e,n,t)=>{if(!e?.props||!e?.props[PropsFlags.REF])return;t.setupState[e.props[PropsFlags.REF]]=n},f=(e,t,o,a,p)=>{null===e?((e,t,o,a)=>{const{type:p,children:i,props:u,shapeFlag:f,transition:g}=e;let d;if(SvgTagArray.includes(p.toLowerCase())){const n=u?.xmlns||DefaultSvgURI;d=e.el=r(n,p)}else d=e.el=l(p);if(u)for(let e in u)e!==PropsFlags.REF&&c(d,e,null,u[e]);f&ShapeFlags.TEXT_CHILDREN?s(d,i):f&ShapeFlags.ARRAY_CHILDREN&&m(i,d,o,a),h(e,d,a),g&&g.beforeEnter(d),n(d,t,o),g&&g.enter(d)})(t,o,a,p):E(e,t,o,a,p)},g=(e,n)=>{for(let t=0;t<e.length;t++){let l=e[t];A(l,n)}},d=(e,t,l,r,o)=>{const a=e.children,p=u(t.children),i=e.shapeFlag,c=t.shapeFlag;c&ShapeFlags.TEXT_CHILDREN?(i&ShapeFlags.ARRAY_CHILDREN&&g(a,o),a!==p&&s(l,p)):i&ShapeFlags.ARRAY_CHILDREN?c&ShapeFlags.ARRAY_CHILDREN?((e,t,l,r)=>{let o=0,a=e.length-1,s=t.length-1;for(;o<=a&&o<=s;){const n=e[o],r=t[o];if(!isSameVnode(n,r))break;R(n,r,l),o++}for(;o<=a&&o<=s;){const n=e[a],r=t[s];if(!isSameVnode(n,r))break;R(n,r,l),a--,s--}if(o>a){if(o<=s){let e=s+1,n=t[e]?.el;for(;o<=s;)R(null,t[o],l,n),o++}}else if(o>s){if(o<=a)for(;o<=a;)A(e[o],r),o++}else{let p=o,i=o;const c=new Map;let u=s-i+1,m=new Array(u).fill(0);for(let e=i;e<=s;e++){const n=t[e];c.set(n.key,e)}for(let n=p;n<=a;n++){const o=e[n],a=c.get(o.key);null==a?A(o,r):(m[a-i]=n+1,R(o,t[a],l))}let h=getSequence(m),f=h.length-1;for(let e=u-1;e>=0;e--){let r=i+e,o=t[r+1]?.el,a=t[r];a.el?e==h[f]?f--:n(a.el,l,o):R(null,a,l,o)}}})(a,p,l,o):g(a,o):(i&ShapeFlags.TEXT_CHILDREN&&s(l,""),c&ShapeFlags.ARRAY_CHILDREN&&m(p,l,r,o))},E=(e,n,t,l,r)=>{let o=n.el=e.el,a=e.props||{},p=n.props||{};const{patchFlag:i,dynamicChildren:u}=n;if(i){if(PatchFlags.STYLE,PatchFlags.CLASS,i&PatchFlags.TEXT&&e.children!==n.children)return s(o,n.children)}else((e,n,t)=>{for(let l in n)c(t,l,e[l],n[l]);for(let l in e)l in n||c(t,l,e[l],null)})(a,p,o);u?((e,n,t,l,r)=>{for(let o=0;o<n.dynamicChildren.length;o++)R(e.dynamicChildren[o],n.dynamicChildren[o],t,l,r)})(e,n,o,l,r):d(e,n,o,l,r)};function F(e){const{render:n,vnode:t,proxy:l,props:r,attrs:o,slots:a}=e;return t.shapeFlag&ShapeFlags.STATEFUL_COMPONENT?n.call(l,l):t.type(o,{slots:a})}function S(e,n,t,l){const r=new ReactiveEffect((()=>{if(e.isMounted){const{next:l}=e;l&&((e,n)=>{e.next=null,e.vnode=n,v(e,e.props,n.props||{}),Object.assign(e.slots,n.children)})(e,l),e._bu&&invokeArray(e._bu);const r=F(e);R(e.subTree,r,n,t,e),e.subTree=r,e._u&&invokeArray(e._u)}else{e._bm&&invokeArray(e._bm);const l=F(e);R(null,l,n,t,e),e.isMounted=!0,e.subTree=l,e._m&&invokeArray(e._m)}}),(()=>queueJob(o))),o=e.update=()=>r.run();o()}const T=(e,n)=>{let t=Object.keys(n);if(t.length!==Object.keys(e).length)return!0;for(let l=0;l<t.length;l++){const r=t[l];if(n[r]!==e[r])return!0}return!1},v=(e,n,t)=>{if(T(n,t)){for(let n in t)e.props[n]=t[n];for(let n in e.props)n in t||delete e.props[n]}},_=(e,n)=>{const t=n.component=e.component;((e,n)=>{const{props:t,children:l}=e,{props:r,children:o}=n;return!(!l&&!o)||t!==r&&T(t,r||{})})(e,n)&&(t.next=n,t.update())},y=(e,t,o,a,s)=>{null===e?t.shapeFlag&ShapeFlags.COMPONENT_KEPT_ALIVE?s.ctx.activate(t,o,a):((e,t,o,a)=>{const s=e.component=createComponentInstance(e,a);isKeepAlive(e)&&(s.ctx.renderer={createElement:l,createElementNS:r,move(e,t,l){n(e.component.subTree.el,t,l)},unmount:A}),setupComponent(s),S(s,t,o)})(t,o,a,s):_(e,t)},R=(e,t,l,r=null,s=null)=>{if(e==t)return;e&&!isSameVnode(e,t)&&(A(e,s),e=null);const{type:p,shapeFlag:i,ref:c}=t;switch(p){case Text:((e,t,l)=>{if(null==e)n(t.el=o(t.children),l);else{const n=t.el=e.el;e.children!==t.children&&a(n,t.children)}})(e,t,l);break;case Fragment:((e,n,t,l,r)=>{null==e?m(n.children,t,l,r):d(e,n,t,l,r)})(e,t,l,r,s);break;default:i&ShapeFlags.ELEMENT?f(e,t,l,r,s):i&ShapeFlags.TELEPORT?p.process(e,t,l,r,s,{mountChildren:m,patchChildren:d,move(e,t,l){n(e.component?e.component.subTree.el:e.el,t,l)}}):i&ShapeFlags.COMPONENT&&y(e,t,l,r,s)}null!==c&&function(e,n){let t=n.shapeFlag&ShapeFlags.STATEFUL_COMPONENT?n.component.exposed||n.component.proxy:n.el;isRef(e)&&(e.value=t)}(c,t)};const A=(e,n)=>{const{shapeFlag:l,transition:r,el:o}=e,a=()=>{t(e.el)};l&ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE?n.ctx.deactivate(e):e.type===Fragment?g(e.children,n):l&ShapeFlags.COMPONENT?A(e.component.subTree,n):l&ShapeFlags.TELEPORT?e.type.remove(e,g):r?r.leave(o,a):a()};return{render:(e,n)=>(null==e?n._vnode&&A(n._vnode,null):(R(n._vnode||null,e,n),n._vnode=e),()=>{e&&e.component&&e.component._um&&invokeArray(e.component._um),A(n._vnode,null),n._vnode=null})}}