import{proxyRefs,reactive}from"../reactivity";import{hasOwn,isFunction,ShapeFlags}from"../shared";export function createComponentInstance(t,e){return{data:null,vnode:t,subTree:null,isMounted:!1,update:null,props:{},attrs:{},slots:{},propsOptions:t.type.props,component:null,proxy:null,setupState:{},exposed:null,parent:e,ctx:{},provides:e?e.provides:Object.create(null)}}const initProps=(t,e)=>{const n={},s={},r=t.propsOptions||{};if(e)for(let t in e){const o=e[t];t in r?n[t]=o:s[t]=o}t.attrs=s,t.props=reactive(n)},publicProperty={$attrs:t=>t.attrs,$slots:t=>t.slots},handler={get(t,e){const{data:n,props:s,setupState:r}=t;if(n&&hasOwn(n,e))return n[e];if(s&&hasOwn(s,e))return s[e];if(r&&hasOwn(r,e))return r[e];const o=publicProperty[e];return o?o(t):void 0},set(t,e,n){const{data:s,props:r,setupState:o}=t;if(s&&hasOwn(s,e))s[e]=n;else{if(r&&hasOwn(r,e))return console.warn("props are readonly"),!1;o&&hasOwn(o,e)&&(o[e]=n)}return!0}};export function initSlots(t,e){t.vnode.shapeFlag&ShapeFlags.SLOTS_CHILDREN?t.slots=e:t.slots={}}export function setupComponent(t){const{vnode:e}=t;initProps(t,e.props),initSlots(t,e.children),t.proxy=new Proxy(t,handler);const{data:n=()=>{},render:s,setup:r}=e.type;if(r){const e={slots:t.slots,attrs:t.attrs,expose(e){t.exposed=e},emit(e,...n){const s=`on${e[0].toUpperCase()+e.slice(1)}`,r=t.vnode.props[s];r&&r(...n)}};setCurrentInstance(t);const n=r(t.props,e);unsetCurrentInstance(),isFunction(n)?t.render=n:t.setupState=proxyRefs(n)}isFunction(n)?t.data=reactive(n.call(t.proxy)):console.warn("data option must be a function"),t.render||(t.render=s)}export let currentInstance=null;export const getCurrentInstance=()=>currentInstance;export const setCurrentInstance=t=>{currentInstance=t};export const unsetCurrentInstance=()=>{currentInstance=null};